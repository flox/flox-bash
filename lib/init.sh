# Set prefix (again) to assist with debugging independently of flox.sh.
_prefix="@@PREFIX@@"
_prefix=${_prefix:-.}
_lib=$_prefix/lib
_etc=$_prefix/etc

# Use extended glob functionality throughout.
shopt -s extglob

# Pull in utility functions early.
. $_lib/utils.sh

# Import library functions.
. $_lib/metadata.sh

#
# Parse flox configuration files in TOML format. Order of processing:
#
# 1. package defaults from $PREFIX/etc/flox.toml
# 2. installation defaults from /etc/flox.toml
# 3. user customizations from $HOME/.floxrc
#
# Latter definitions override/redefine the former ones.
#
read_flox_conf()
{
	local _cline
	# Consider other/better TOML parsers. Calling dasel multiple times below
	# because it only accepts one query per invocation.  In benchmarks it claims
	# to be 3x faster than jq so this is better than converting to json in a
	# single invocation and then selecting multiple values using jq.
	for f in "$_prefix/etc/flox.toml" "/etc/flox.toml" "$HOME/.floxrc"
	do
		if [ -f "$f" ]; then
		for i in $@
			do
				# Use eval() to incorporate autogenerated code to read TOML values.
				#
				# Use `cat` to open files because it produces a clear and concise
				# message when file is not found or not readable. By comparison
				# the equivalent dasel output is to report "unknown parser".
				#
				# Use jq to look for the requested attribute because dasel always
				# returns nonzero when it is not found.
				#
				# Use the `jq` `tojson()` function to escape quotes contained in
				# values.
				eval $(
					$_cat "$f" | \
					$_dasel -p toml -w json | \
					jq -r --arg var $i '
						select(has($var)) | .[$var] | to_entries | map(
							"FLOX_CONF_\(.key)=\(.value | tojson)"
						) | join("\n")
					'
				)
			done
		fi
	done
}

nix_show_config()
{
	local -a _cline
	$_nix show-config | while read -a _cline
	do
		case "${_cline[0]}" in
		# List below the parameters you want to use within the script.
		system)
			local _xline=$(echo "${_cline[@]}" | $_tr -d ' \t')
			echo NIX_CONFIG_"$_xline"
			;;
		*)
			;;
		esac
	done
}

#
# Global variables
#

# NIX honors ${USER} over the euid, so make them match.
export USER=$($_id -un)
export HOME=$($_getent passwd ${USER} | $_cut -d: -f6)
export PWD=$($_pwd)

# Define and create flox metadata cache, data, and profiles directories.
export FLOX_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}/flox"
export FLOX_PROFILEMETA="$FLOX_CACHE_HOME/profilemeta"
export FLOX_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}/flox"
export FLOX_PROFILES="$FLOX_DATA_HOME/profiles"
export FLOX_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}/flox"
$_mkdir -p "$FLOX_CACHE_HOME" "$FLOX_PROFILEMETA" "$FLOX_DATA_HOME" "$FLOX_PROFILES" "$FLOX_CONFIG_HOME"

# Prepend FLOX_DATA_HOME to XDG_DATA_DIRS. XXX Why? Probably delete ...
# XXX export XDG_DATA_DIRS="$FLOX_DATA_HOME"${XDG_DATA_DIRS:+':'}${XDG_DATA_DIRS}

# Define place to store user-specific metadata separate
# from profile metadata.
floxUserMeta="$FLOX_CONFIG_HOME/floxUserMeta.json"

# Define location for user-specific flox flake registry.
floxFlakeRegistry="$FLOX_CONFIG_HOME/floxFlakeRegistry.json"

# Manage user-specific nix.conf for use with flox only.
# XXX May need further consideration for Enterprise.
nixConf="$FLOX_CONFIG_HOME/nix.conf"
tmpNixConf=$($_mktemp --tmpdir=$FLOX_CONFIG_HOME)
$_cat > $tmpNixConf <<EOF
# Automatically generated - do not edit.
experimental-features = nix-command flakes
netrc-file = $HOME/.netrc
flake-registry = $floxFlakeRegistry
accept-flake-config = true
warn-dirty = false
EOF

# Ensure file is secure before appending access token(s).
$_chmod 600 $tmpNixConf

# If found, extract and append github token from gh file.
if [ -f "$HOME/.config/gh/hosts.yml" ]; then
	$_dasel -r yml -w json < "$HOME/.config/gh/hosts.yml" | $_jq -r '
		"access-tokens = " + (
			to_entries |
			map(select(.value.oauth_token != null)) |
			map("\(.key)=\(.value.oauth_token)") |
			join(" ")
		)' >> $tmpNixConf
fi

if $_cmp --quiet $tmpNixConf $nixConf; then
	$_rm $tmpNixConf
else
	echo "Updating $nixConf" 1>&2
	$_mv -f $tmpNixConf $nixConf
fi
export NIX_REMOTE=daemon
export NIX_USER_CONF_FILES="$nixConf"
export NIX_SSL_CERT_FILE="@@SSL_CERT_FILE@@"

# Load nix configuration (must happen after setting NIX_USER_CONF_FILES)
eval $(nix_show_config)

# Load configuration from [potentially multiple] flox.toml config file(s).
eval $(read_flox_conf npfs floxpkgs)

# Bootstrap user-specific configuration.
. $_lib/bootstrap.sh

# Populate user-specific flake registry.
# FIXME: support multiple flakes.
# Note: avoids problems to let nix create the temporary file.
tmpFloxFlakeRegistry=$($_mktemp --dry-run --tmpdir=$FLOX_CONFIG_HOME)
minverbosity=2 $invoke_nix registry add --registry $tmpFloxFlakeRegistry floxpkgs $defaultFlake
minverbosity=2 $invoke_nix registry add --registry $tmpFloxFlakeRegistry nixpkgs github:flox/nixpkgs/${FLOX_STABILITY:-stable}
if $_cmp --quiet $tmpFloxFlakeRegistry $floxFlakeRegistry; then
	$_rm $tmpFloxFlakeRegistry
else
	$_mv -f $tmpFloxFlakeRegistry $floxFlakeRegistry
fi

# String to be prepended to flox flake uri.
floxpkgsUri="flake:floxpkgs"

# String to be prepended to flake attrPath (before channel).
catalogAttrPathPrefix="legacyPackages.$NIX_CONFIG_system.catalog"

# Leave it to Bob to figure out that Nix 2.3 has the bug that it invokes
# `tar` without the `-f` flag and will therefore honor the `TAPE` variable
# over STDIN (to reproduce, try running `TAPE=none flox shell`).
# XXX Still needed??? Probably delete ...
if [ -n "$TAPE" ]; then
	unset TAPE
fi

# Timestamp
now=$($_date +%s)

# vim:ts=4:noet:syntax=bash
